<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1014考试总结]]></title>
    <url>%2F2018%2F10%2F14%2F10-14%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这是10.14的考试总结。 首先要承认自己的一个锅，今天第三题的前三组数据我跑错了……因为我把n开到了5000但左区间和右区间却有可能会到10000导致好多查询是有问题的。所以前三组大家都wa了……所以要给大家承认个错误…… 既然说到第三题了，那就先写第三题的题解吧。 题面应该是不能给，大致就是一道要求区间增加和区间查询的题，数据开到了50000而时间只有0.2秒，这样的话普通线段树大概是写不成了，因为常数过于大。那么写法的话我想到了三种正解：zkw线段树，树状数组和分块。由于分块的写法比较简单（才不是因为这道题的题目就叫分块）就直接写分块了。题挺裸的，基本属于板子题没什么可说的。但这道题由于数据出了问题，临时的数据是我出的，这个数据我就有点话想说了。]]></content>
      <categories>
        <category>总结</category>
        <category>经验</category>
        <category>考试</category>
      </categories>
      <tags>
        <tag>noip模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL - bitset 的使用]]></title>
    <url>%2F2018%2F10%2F12%2Fbitset%2F</url>
    <content type="text"><![CDATA[听说这年头竟然有很多人都不会bitset(比如我)，这一篇文章就说说bitset的基本用法吧。 引入首先第一个问题，什么是bitset。其实bitset是一个模版类，但它的模版参数不是类型，而是整型的数值。有了这个东西以后，我们就可以像数组一样使用位进行运算了。 举个栗子 123456789#include &lt;bitset&gt;using namespace std;int main() &#123; bitset&lt;16&gt; ff1(100); cout &lt;&lt; ff1 &lt;&lt; endl;&#125; (上面的程序肯定是运行不了的，需要再加几个库)结果是这样的： 10000000001100100 最通俗地来讲，bitset就是一个可以存储二进制数位的一个类型，基本就相当于一个布尔数组（布尔数组也可以转化成bitset类型），那么问题来了我们为啥不直接用布尔数组而是要学bitset呢？很简单因为bitset对空间有着很显著的优化，bitset中的一个元素一般只占1bit的空间，什么概念呢，相当于一个char类型的八分之一。所以当你遇到了丧心病狂的出题人出比较高端的压位卡常题的时候就需要这个东西的帮助了。 定义和数组一样，bitset的长度在最开始定义的时候就要进行确认，如果需要不定长的bitset的话请用vector。 可以转化成bitset的类型有很多就像上面的整型，除此之外还有string，甚至可以直接转化布尔数组。当然也可以直接定义一个空的bitset来进行你想要的操作，来让我们拓展一下上面的程序： 1234567891011121314#include &lt;bitset&gt;using namespace std;int main() &#123; bitset&lt;16&gt; ff1; bitset&lt;16&gt; ff2(100); bitset&lt;16&gt; ff3(string(&quot;0110110101&quot;)); bitset&lt;16&gt; ff4(a); cout &lt;&lt; ff1 &lt;&lt; endl; cout &lt;&lt; ff2 &lt;&lt; endl; cout &lt;&lt; ff3 &lt;&lt; endl;&#125; 结果就是 123000000000000000000000000011001000000000110110101 (布尔数组转化bitset一般用不到就不演示了有兴趣自己下去试试) 另外，由于bitset还重载了运算符”[]”的原因所以 12bitset&lt;16&gt; ff;ff[4] = 1; 这种直接把第5位赋值为1的操作也是存在的。 运算和一般的整型变量一样，bitset支持and, or, xor, &lt;&lt;, &gt;&gt;的操作，这个是可以直接进行运算的，效果和一般的位运算是一模一样的。 123456789101112131415#include &lt;bitset&gt;using namespace std;int mian() &#123; bitset&lt;4&gt; ff1(10);//1010 bitset&lt;4&gt; ff2(12);//1100 cout &lt;&lt; (ff1 &amp; ff2) &lt;&lt; endl; cout &lt;&lt; (ff1 | ff2) &lt;&lt; endl; cout &lt;&lt; (ff1 ^ ff2) &lt;&lt; endl; cout &lt;&lt; (ff1 &lt;&lt; 1) &lt;&lt;endl; cout &lt;&lt; (ff1 &gt;&gt; 1) &lt;&lt;endl; cout &lt;&lt; (~ff1) &lt;&lt;endl;&#125; 结果为 123456100011100110010001010101 所以在各种位运算中完全可以用bitset来执行各类操作来起到优化空间的作用。 相关函数对于一个叫做ff的bitset类来讲1234567891011121314ff.size() //返回位数ff.count() //返回1的个数ff.any() //返回是否有1ff.none() //返回是否没有1ff.set() //全都变成1ff.set(p) //将第p + 1位变成1ff.set(p, x) //将第p + 1位变成xff.reset() //全都变成0ff.reset(p) //将第p + 1位变成0ff.flip() //全都取反ff.flip(p) //将第p + 1位取反ff.to_ulong() //返回它转换为unsigned long的结果，如果超出范围则报错ff.to_ullong() //返回它转换为unsigned long long的结果，如果超出范围则报错ff.to_string() //返回它转换为string的结果 这个相信就不需要我进行什么说明了，会一点STL的一般都懂。 相关习题其实裸的bitset题真的不多，这个与其说是一种算法不如说是意志优化手段更为妥当一点所以我找的题不多 BZOJ - 2208https://www.lydsy.com/JudgeOnline/problem.php?id=2208 给的数据范围是一个很明显的Floyd但直接写会TLE，可以考虑可以开n个bitset f[i]表示i可以到达的点集，每次传递闭包的时候or一下就好了。 CH - 2101 http://contest-hunter.org:83/contest/0x20%E3%80%8C%E6%90%9C%E7%B4%A2%E3%80%8D%E4%BE%8B%E9%A2%98/2101%20%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%BB%9F%E8%AE%A1 这道题很明显可以得到一个“从x出发的点是从x的各个后继节点y出发能到达的点的并集加上自身就就是答案”的结论。这样做法就很明显了，先topsort一下，然后从后往前进行递推，bitset f[i]和前一道一样表示从x出发能到达点的数量，对各个后继节点y出发能到达的点求并也就是or操作一下就可以了。 我最近也就做到了这两道题，以后如果有的话就继续加进来。 这篇文章就酱。]]></content>
      <categories>
        <category>STL 经验</category>
      </categories>
      <tags>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1011考试总结]]></title>
    <url>%2F2018%2F10%2F11%2F1011%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这是jjh大佬出的一场考试题。 总结这场考试我的总分是165。100分是第一天的t2，65是第二天的t1。分数有点低了，关键还是我自己在最近的考试里不太想打暴力一直都是100 or 0。由于我比较菜这场考试里能a的题感觉就两道，有一道还写挂了，然后就心态爆炸。day1我写t1写了很长时间，一眼看出来应该是一个组合数，看了眼数据200000就先写了个O(n)逆元求组合数预处理了一下。思路应该没有什么错，但就是这个公式在中间推的时候出了一些莫名其妙的错误导致我最后没办法求，这一道题写了快3个小时，最后没办法了，看了看第二题，也是一眼看出来是一个二分答案+贪心，但这个不太好写攻略，所以我就大胆猜想了一波（其实就是乱搞），最后竟然还过了就很舒服。今天的话是看题看的心态爆炸因为一道题都不会，每道题的正解让我想都想不到，然后开始狂写看起来比较简单的第一题，写挂了，最后也是没办法了把用来对拍的暴力交了上去，然后因为我中间的双指针写的过于丑陋80卡到了65。 一脸绝望.jpg。 其实说起来jjh大佬的题虽然正解都很鬼畜但也不是完全不可做，起码还是有很实惠的部分分可拿的，但我自己考试的问题不打暴力，我感觉自己要好好反省一波了。 题解另外题解的话因为题还没有讲完就先不写了，回来补上。]]></content>
      <categories>
        <category>总结 经验 考试</category>
      </categories>
      <tags>
        <tag>noip模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在最前面的话]]></title>
    <url>%2F2018%2F10%2F10%2F%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[从很早很早以前退役到前一阵子回到机房，似乎过了很长时间——不用似乎，说起来也确实很长——大概有大半年了吧。 按理说，像我这种有了省一而且文化课也不是很稳定的人就该乖乖滚回班。毕竟省选太难，再拿一个省一作用也不是很大，最关键的是搞oi会耽误我很多时间有可能把本来还差不多的文化课拉下很多得不偿失。我现在的这种选择别说别人，就我自己都觉得十分不明智，我对自己几斤几两还是有点b数的，一等还行，进队很难。退一万步说我就算进了队估计在全国赛也打不出什么集训队的成绩，大概率是个Cu，提前一周去五台山拜拜估计撑死是个末位Ag。 但我还觉得吧，像我这种正处青春期叛逆期的人就得干出一些明知不可为而为之的事。其实也不是为了较真儿，就是这事不做将会是人生的一个遗憾吧。对一个学生而言，能站在全国的舞台上打比赛的机会其实不多，无非noi和acm，不去试试自己真的很不爽。 我以前总结过我自己的性格，我就属于那种有什么看起来很难的事，就先做做试试，不行就再来一遍，还不行就继续，到自己头破血流为止。南墙我是一定要撞的，有多疼撞了再说。现在我面前的墙就是noip，我想去尽自己的力去打一次比赛而不像去年那样随意，先不说结果怎么样，有这样的经历我就已经觉得很满足了。 可以说，这次去noip就是我近几年最大的任性。你看这性都任了，不好好拼一次命多不好意思啊。 最近的话除了打比赛，总结一遍 搜索， DP， 图论， 数论， 数据结构的相关知识点，现在离noip还有一个多月，再刷150道题吧。 先定一个小目标，noip500分吧。梦想是要有的，不然你怎么体验绝望（滑稽） 就酱吧，现在终于把自己的博客整好了，那就每日都更新吧，尽量日更。希望我今年的努力不要化为泡影。]]></content>
      <categories>
        <category>总结 经验</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
</search>
